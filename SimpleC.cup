import java_cup.runtime.*;
import java.util.*;


parser code {:

public void syntax_error(Symbol curToken) {
    if (curToken.value == null) {
       Errors.fatal(0,0, "SYNTAX ERROR at end of file");
    }
    else {
       MySymbol cur = (MySymbol)curToken;
       Errors.fatal(cur.getLine(), cur.getColumn(),
            "SYNTAX ERROR while reading token " + ((Scanner)this.getScanner()).getTokName(cur.sym) + " ("+ ((Scanner)this.getScanner()).yytext() + ")");
    }
    System.exit(-1);
}

:};


/* Terminals */

terminal            INT;
terminal            BOOL;
terminal            VOID;
terminal Boolean    TRUE;
terminal Boolean    FALSE;
terminal            NULL;
terminal            IF;
terminal            ELSE;
terminal            WHILE;
terminal            FOR;
terminal            RETURN;
terminal String     ID;
terminal String     INTLITERAL;
terminal String     STRINGLITERAL;
terminal String     REALLITERAL;
terminal String     CHARLITERAL;
terminal            LCURLY;
terminal            RCURLY;
terminal            LSQBRACKET;
terminal            RSQBRACKET;
terminal            LPAREN;
terminal            RPAREN;
terminal            COMMA;
terminal            ASSIGN;
terminal            SEMICOLON;
terminal            PLUS;
terminal            MINUS;
terminal            TIMES;
terminal            DIVIDE;
terminal            BANG;
terminal            AND_OP;
terminal            OR_OP;
terminal            EQUALS;
terminal            NE_OP;
terminal            LESS;
terminal            GREATER;
terminal            LE_OP;
terminal            GE_OP;
terminal            AMPERSAND;
terminal            SIZEOF;
terminal            FULLSTOP;
terminal            STRUCT;
terminal            ADD_ASSIGN;
terminal            SUB_ASSIGN;
terminal            MUL_ASSIGN;
terminal            DIV_ASSIGN;
terminal            PERCENT;
terminal            COLON;

terminal            EXTERN;
terminal            COMMENTBLOCK;
terminal            COMMENTLINE;
terminal            AUTO;
terminal            BREAK;
terminal            CASE;
terminal            CHAR;
terminal            CONTINUE;
terminal            DEFAULT;
terminal            DOUBLE;
terminal            ENUM;
terminal            GOTO;
terminal            LONG;
terminal            REGISTER;
terminal            SHORT;
terminal            SIGNED;
terminal            STATIC;
terminal            SWITCH;
terminal            TYPEDEF;
terminal            UNION;
terminal            UNSIGNED;
terminal            VOLATILE;
terminal            ELLIPSIS;
terminal            RIGHT_ASSIGN;
terminal            LEFT_ASSIGN;
terminal            MOD_ASSIGN;
terminal            AND_ASSIGN;
terminal            XOR_ASSIGN;
terminal            OR_ASSIGN;
terminal            RIGHT_OP;
terminal            LEFT_OP;
terminal            INC_OP;
/*terminal            DEC_OP;*/
terminal            PTR_OP;
terminal            TILDE;
terminal            CARET;
terminal            VERTICALBAR;
terminal            QUESTIONMAR;
terminal            HASH;
terminal            DO;
terminal            CONST;
terminal            FLOAT;


/* Nonterminals */

non terminal Program          program;
non terminal LinkedList       declList;
non terminal Decl             decl;
non terminal LinkedList       varDeclList;
non terminal VarDecl          varDecl;
non terminal FuncDef          funcDef;
non terminal FormalsList      formals;
non terminal FuncBody         funcBody;
non terminal LinkedList       stmtList;
non terminal Stmt             stmt;
non terminal Expr             exp;
non terminal Term             term;
non terminal Type             type;
non terminal Loc              loc;
non terminal ID               id;

non terminal FormalDecl       formalDecl;
non terminal LinkedList       formalsList;
non terminal BinaryExpr       binaryExpr;
non terminal ArrayExpr        arrayExpr;
non terminal LinkedList       actualList;
non terminal CallExpr         callExpr;
non terminal UnaryExpr        unaryExpr;
non terminal FuncDecl         funcDecl;
non terminal StructDecl       structDecl;

non terminal AssignStmt   assignStmt;
non terminal IfStmt		ifStmt;
non terminal IfElseStmt		ifElseStmt;
non terminal ForStmt		forStmt;
non terminal AssignStmt		forInitStmt;
non terminal WhileStmt		whileStmt;
non terminal ReturnStmt		returnStmt;
non terminal CallStmt   callStmt;

precedence left VERTICALBAR;
precedence left AMPERSAND;
precedence nonassoc EQUALS, NE_OP;
precedence nonassoc LESS, GREATER, LE_OP, GE_OP;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, PERCENT;

precedence right SIZEOF;
precedence right BANG;


start with program;

/*
 * grammar with actions
 */

program ::= declList: d {: RESULT = new Program(new DeclList(d)); :}
          ;

declList ::= declList: dl decl: d {: dl.addLast(d); RESULT = dl; :}
           | /* epsilon */ {: RESULT = new LinkedList(); :}
           ;

decl ::= varDecl: v {: RESULT = v; :}
       | funcDef: f {: RESULT = f; :}
       | funcDecl: f {: RESULT = f; :}
       | structDecl: s {: RESULT = s; :}
       ;

/*
http://www2.cs.tum.edu/projects/cup/
LALR
*/
varDecl ::= type: t id: i SEMICOLON
             {: RESULT = new VarDecl(t, i); :}
          | type: t id: i LSQBRACKET INTLITERAL: il RSQBRACKET SEMICOLON
            {: RESULT = new VarDecl(t, i, new IntLiteral(il)); :}
          ;

funcDef ::= type: t id: i formals: f funcBody: body {: RESULT = new FuncDef(t, 0, i, f, body); :}
         ;

funcDecl ::= type: t id: i formals: f SEMICOLON {: RESULT = new FuncDecl(t, i, f); :}
        ;

formals ::= LPAREN formalsList: fl RPAREN {: RESULT = new FormalsList(fl); :}
        ;

formalsList ::= formalDecl: fmd  {:
                LinkedList<FormalDecl> list = new LinkedList<FormalDecl>();
                list.addLast(fmd);
                RESULT = list;
              :}
          | formalDecl: fmd COMMA formalsList: fml {: fml.addFirst(fmd); RESULT = fml; :}
          |  /* epsilon */ {: RESULT = new LinkedList(); :}
          ;

formalDecl ::= type: t id: i {: RESULT = new FormalDecl(t, i); :}
          ;

structDecl ::= STRUCT id: i LCURLY varDeclList: v RCURLY SEMICOLON
          {: RESULT = new StructDecl(i, new VarDeclList(v)); :}
          ;

funcBody ::= LCURLY varDeclList: v stmtList: s RCURLY
              {: RESULT = new FuncBody(new VarDeclList(v), new StmtList(s)); :}
         ;

varDeclList ::= varDeclList: l varDecl: var {: l.addLast(var); RESULT = l; :}
              | /* epsilon */ {: RESULT = new LinkedList(); :}
              ;

stmtList ::= stmtList: l stmt: s {: l.addLast(s); RESULT = l; :}
          |  /* epsilon */ {: RESULT = new LinkedList(); :}
          ;

stmt ::= assignStmt: a SEMICOLON {: RESULT = a; :}
        | ifStmt: b {: RESULT = b; :}
		    | ifElseStmt: c {: RESULT = c; :}
		    | forStmt: d {: RESULT = d; :}
		    | whileStmt: e {: RESULT = e; :}
		    | returnStmt: f {: RESULT = f; :}
		    | callStmt: g {: RESULT = g; :}
      ;

assignStmt ::= loc: l ASSIGN exp: e {: RESULT = new AssignStmt(l, e); :}
| loc: l ADD_ASSIGN exp: e {: RESULT = new AssignStmt(l, new PlusExpr(l, e)); :}
| loc: l SUB_ASSIGN exp: e {: RESULT = new AssignStmt(l, new MinusExpr(l, e)); :}
| loc: l MUL_ASSIGN exp: e {: RESULT = new AssignStmt(l, new TimesExpr(l, e)); :}
| loc: l DIV_ASSIGN exp: e {: RESULT = new AssignStmt(l, new DivideExpr(l, e)); :}
         ;

callStmt ::= callExpr: c SEMICOLON {: RESULT = new CallStmt(c); :}
      ;

ifStmt ::= IF LPAREN exp: e RPAREN LCURLY varDeclList: l stmtList: stm RCURLY
          {: RESULT = new IfStmt(e, new VarDeclList(l), new StmtList(stm)); :}
      		;

ifElseStmt ::= IF LPAREN exp: e RPAREN LCURLY varDeclList: l1 stmtList: stm1 RCURLY ELSE LCURLY varDeclList: l2 stmtList: stm2 RCURLY
        {: RESULT = new IfElseStmt(e, new VarDeclList(l1), new StmtList(stm1), new VarDeclList(l2), new StmtList(stm2)); :}
      		;

forStmt ::= FOR LPAREN forInitStmt: init1 SEMICOLON exp: e SEMICOLON forInitStmt: init2 RPAREN LCURLY varDeclList: l stmtList: stm RCURLY {: RESULT = new ForStmt(init1, e, init2, new VarDeclList(l), new StmtList(stm)); :}
      		;

forInitStmt ::=  assignStmt: a {: RESULT = a; :}
      			| /* epsilon */ {: RESULT = null; :}
      		;

whileStmt ::= WHILE LPAREN exp: e RPAREN LCURLY varDeclList: l stmtList: stm RCURLY
        {: RESULT = new WhileStmt(e, new VarDeclList(l), new StmtList(stm)); :}
      		;

returnStmt ::= RETURN exp: e SEMICOLON  {: RESULT = new ReturnStmt(e); :}
      		| RETURN SEMICOLON {: RESULT = new ReturnStmt(); :}
      		;

exp ::= binaryExpr: b {: RESULT = b; :}
      | term: t {: RESULT = t; :}
      | unaryExpr: u {: RESULT = u; :}
      ;

unaryExpr ::= AMPERSAND exp: e {: RESULT = new AddrOfExpr(e); :}
      | BANG exp: e {: RESULT = new NotExpr(e); :}
      | MINUS exp: e {: RESULT = new MinusUnaryExpr(e); :}
      ;

binaryExpr ::= exp: e1 PLUS exp: e2 {: RESULT = new PlusExpr(e1, e2); :}
        | exp: e1 MINUS exp: e2 {: RESULT = new MinusExpr(e1, e2); :}
        | exp: e1 TIMES exp: e2 {: RESULT = new TimesExpr(e1, e2); :}
        | exp: e1 DIVIDE exp: e2 {: RESULT = new DivideExpr(e1, e2); :}
        | exp: e1 PERCENT exp: e2 {: RESULT = new PercentExpr(e1, e2); :}
        | exp: e1 AMPERSAND exp: e2 {: RESULT = new AndExpr(e1, e2); :}
        | exp: e1 VERTICALBAR exp: e2 {: RESULT = new OrExpr(e1, e2); :}
        | exp: e1 EQUALS exp: e2 {: RESULT = new EqualsExpr(e1, e2); :}
        | exp: e1 NE_OP exp: e2 {: RESULT = new NotEqualsExpr(e1, e2); :}
        | exp: e1 LESS exp: e2 {: RESULT = new LessExpr(e1, e2); :}
        | exp: e1 GREATER exp: e2 {: RESULT = new GreaterExpr(e1, e2); :}
        | exp: e1 LE_OP exp: e2 {: RESULT = new LessEqExpr(e1, e2); :}
        | exp: e1 GE_OP exp: e2 {: RESULT = new GreaterEqExpr(e1, e2); :}
        ;

term ::= loc: l {: RESULT = l; :}
       | INTLITERAL: i {: RESULT = new IntLiteral(i); :}
       | REALLITERAL: r {: RESULT = new RealLiteral(r); :}
       | STRINGLITERAL: s {: RESULT = new StringLiteral(s); :}
       | CHARLITERAL: c {: RESULT = new CharLiteral(c); :}
       | TRUE {: RESULT = new True(); :}
       | FALSE {: RESULT = new False(); :}
       | NULL {: RESULT = new Null(); :}
       | callExpr: c {: RESULT = c; :}
       | SIZEOF LPAREN id: i RPAREN {: RESULT = new Sizeof(i); :}
       | LPAREN exp: e RPAREN {: RESULT = new BoundedExpr(e); :}
       ;

callExpr ::=  id: i LPAREN actualList: a RPAREN {: RESULT = new CallExpr(i, new ActualList(a)); :}
      ;

actualList ::= exp: e {: LinkedList<Expr> list = new LinkedList<Expr>();
                list.addLast(e);
                RESULT = list; :}
      | actualList: al COMMA exp: e {: al.addLast(e); RESULT = al; :}
      | /* epsilon */ {: RESULT = new LinkedList(); :}
      ;

type ::= INT {: RESULT = new IntType(); :}
       | VOID {: RESULT = new VoidType(); :}
       | BOOL {: RESULT = new BoolType(); :}
       | DOUBLE {: RESULT = new DoubleType(); :}
       | CHAR {: RESULT = new CharType(); :}
       | STRUCT id: i {: RESULT = new StructType(i); :}
       ;

loc ::= id: i {: RESULT = i; :}
      | arrayExpr: a {: RESULT = a; :}
      | loc: l FULLSTOP id: i {: RESULT = new AccessLoc(l, i); :}
      ;

arrayExpr ::= loc: l LSQBRACKET exp: e RSQBRACKET {: RESULT = new ArrayExpr(l, e); :}
      ;

id ::= ID: i {: RESULT = new ID(i); :}
     ;
